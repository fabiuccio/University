
//----------------------------------------------------
// The following code was generated by CUP v0.10k
// Mon Feb 26 03:29:18 CET 2007
//----------------------------------------------------

import java_cup.runtime.*;
import java.io.*;
import java.util.HashMap;
import java.util.Vector;

/** CUP v0.10k generated parser.
  * @version Mon Feb 26 03:29:18 CET 2007
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\031\000\002\002\004\000\002\014\003\000\002\015" +
    "\003\000\002\012\004\000\002\012\003\000\002\003\007" +
    "\000\002\003\006\000\002\003\007\000\002\003\006\000" +
    "\002\004\005\000\002\004\005\000\002\004\005\000\002" +
    "\013\007\000\002\005\004\000\002\006\007\000\002\006" +
    "\007\000\002\011\004\000\002\011\004\000\002\011\004" +
    "\000\002\011\004\000\002\011\002\000\002\007\012\000" +
    "\002\007\012\000\002\010\005\000\002\010\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\065\000\006\003\006\014\004\001\002\000\006\003" +
    "\031\015\067\001\002\000\004\002\000\001\002\000\004" +
    "\004\062\001\002\000\004\002\uffff\001\002\000\004\004" +
    "\013\001\002\000\004\002\012\001\002\000\004\002\001" +
    "\001\002\000\010\003\uffed\005\uffed\014\uffed\001\002\000" +
    "\010\003\006\005\015\014\020\001\002\000\012\002\ufffb" +
    "\003\ufffb\005\ufffb\014\ufffb\001\002\000\010\003\uffee\005" +
    "\uffee\014\uffee\001\002\000\010\003\ufff1\005\ufff1\014\ufff1" +
    "\001\002\000\006\003\031\015\032\001\002\000\010\003" +
    "\uffef\005\uffef\014\uffef\001\002\000\010\003\006\005\030" +
    "\014\004\001\002\000\006\004\013\021\026\001\002\000" +
    "\010\003\ufff0\005\ufff0\014\ufff0\001\002\000\010\003\ufffd" +
    "\005\ufffd\014\ufffd\001\002\000\010\003\ufff4\005\ufff4\014" +
    "\ufff4\001\002\000\010\003\ufffe\005\ufffe\014\ufffe\001\002" +
    "\000\012\002\ufffc\003\ufffc\005\ufffc\014\ufffc\001\002\000" +
    "\004\020\061\001\002\000\014\003\033\004\036\016\037" +
    "\017\035\020\034\001\002\000\006\004\ufff6\021\ufff6\001" +
    "\002\000\006\004\ufff8\021\ufff8\001\002\000\004\020\053" +
    "\001\002\000\004\022\051\001\002\000\004\020\040\001" +
    "\002\000\006\006\042\021\041\001\002\000\010\003\ufff2" +
    "\005\ufff2\014\ufff2\001\002\000\004\020\044\001\002\000" +
    "\006\007\045\013\046\001\002\000\006\007\uffe9\013\uffe9" +
    "\001\002\000\004\021\050\001\002\000\004\020\047\001" +
    "\002\000\006\007\uffea\013\uffea\001\002\000\010\003\uffec" +
    "\005\uffec\014\uffec\001\002\000\004\005\052\001\002\000" +
    "\010\003\ufff5\005\ufff5\014\ufff5\001\002\000\006\006\055" +
    "\021\054\001\002\000\010\003\ufff3\005\ufff3\014\ufff3\001" +
    "\002\000\004\020\044\001\002\000\006\007\057\013\046" +
    "\001\002\000\004\021\060\001\002\000\010\003\uffeb\005" +
    "\uffeb\014\uffeb\001\002\000\006\004\ufff7\021\ufff7\001\002" +
    "\000\010\003\uffed\005\uffed\014\uffed\001\002\000\010\003" +
    "\006\005\064\014\020\001\002\000\012\002\ufff9\003\ufff9" +
    "\005\ufff9\014\ufff9\001\002\000\010\003\006\005\066\014" +
    "\004\001\002\000\012\002\ufffa\003\ufffa\005\ufffa\014\ufffa" +
    "\001\002\000\006\003\033\020\034\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\065\000\012\003\006\004\007\014\010\015\004\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\011\013\001\001\000\020\003\024" +
    "\004\022\005\016\006\023\007\020\012\021\013\015\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\003\026\004" +
    "\007\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\010\042\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\010\055\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\011\062\001\001\000\020\003\024\004\022" +
    "\005\016\006\023\007\020\012\064\013\015\001\001\000" +
    "\002\001\001\000\006\003\026\004\007\001\001\000\002" +
    "\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {
		
	//poniamo qui comportamenti da eseguire a priori dall'evoluzione del programma
    symbol_table = new HashMap();

    }


    public static int trovato_fatto  = 0;
    public static int trovati_errori = 0;
    public HashMap symbol_table;
    public static BackBone bz;
    public static String socDoc;
	
    public static void main(String argv[]){
        try {
            bz = new BackBone(); //Creazione di comodo della struttura senza package
            socDoc = new String();

            /* Istanzio lo scanner aprendo il file di ingresso argv[0] */
            Lexer l = new Lexer(new FileReader(argv[0]));
            /* Istanzio il parser */
            parser p = new parser(l);
            /* Avvio il parser */
            Object result = p.parse().value;      
            } catch (NullPointerException e){
                    e.printStackTrace();
                    System.err.println("Errore in grammatica");
            } catch (FileNotFoundException e){
                    System.err.println("Errore: non riesco ad aprire il file " + argv[0]);
            } catch (Exception e){
                    e.printStackTrace();
            }
        }

        public void syntax_error(Symbol simbolo_attuale) {
            StringBuffer m = new StringBuffer("Errore");

            if (simbolo_attuale.left != -1) {                
                m.append(" in linea " + (simbolo_attuale.left+1));   
                m.append(", colonna " + (simbolo_attuale.right+1));
            }
            m.append(", simbolo: " + (simbolo_attuale));
            m.append(" : errore di sintassi...");

            parser.bz.addErrorLog(BackBone.SYNTAX, m.toString());
            parser.bz.toFile(); //Viene scritto di volta in volta ad ogni errore trovato...
        }
 

        public void report_error(String message, Object info) {
            StringBuffer m = new StringBuffer("Errore");
            m.append(" : " + message);
            System.err.println(m);
        }

        public void report_fatal_error(String message, Object info) {
            report_error(message, info);
            System.exit(1);
        }


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {
  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // lista_atomo ::= ATOMO 
            {
              Vector RESULT = null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		
    System.out.println("[DEBUG] ATOMO found: "+a);
    RESULT = new Vector();
    RESULT.add(a);

              CUP$parser$result = new java_cup.runtime.Symbol(6/*lista_atomo*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // lista_atomo ::= lista_atomo VIR ATOMO 
            {
              Vector RESULT = null;
		int laleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int laright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Vector la = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		String b = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		
    System.out.println("[DEBUG] LISTA_ATOMO found ("+la.size()+" atoms)");
    la.add(b);
    RESULT=la;

              CUP$parser$result = new java_cup.runtime.Symbol(6/*lista_atomo*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // complex_expr ::= ATTRIBUZIONE KEYWORD MY_TYPE ATOMO QUADRAPERTA lista_atomo QUADRACHIUSA PTVIR 
            {
              Vector RESULT = null;
		int kwleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int kwright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		String kw = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int mtleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int mtright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		String mt = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int laleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int laright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Vector la = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		

    System.out.println("[DEBUG] COMPLEX_EXPR with a MYTYPE found: "+kw);
    RESULT.add(kw); //Vector(0)=Keyword
    RESULT.add(mt); //Vector(1)=Type
    RESULT.add(a); //Vector(2)=Atomo
    RESULT.addAll(la); //Vector(3toN)=Vector+All elements of lista atomo

              CUP$parser$result = new java_cup.runtime.Symbol(5/*complex_expr*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // complex_expr ::= ATTRIBUZIONE KEYWORD TYPE ATOMO QUADRAPERTA lista_atomo QUADRACHIUSA PTVIR 
            {
              Vector RESULT = null;
		int kwleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int kwright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		String kw = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		String t = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int laleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int laright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Vector la = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
    System.out.println("[DEBUG] COMPLEX_EXPR with a TYPE found: "+kw);
    RESULT = new Vector();
    RESULT.add(kw); //Vector(0)=Keyword
    RESULT.add(t); //Vector(1)=Type
    RESULT.add(a); //Vector(2)=Atomo
    RESULT.addAll(la); //Vector(3toN)=Vector+All elements of lista atomo;

              CUP$parser$result = new java_cup.runtime.Symbol(5/*complex_expr*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // lista_expr ::= 
            {
              Vector RESULT = null;
		
    System.out.println("[DEBUG] LISTA_EXPRESSION with an epsilon");
    RESULT = new Vector();

              CUP$parser$result = new java_cup.runtime.Symbol(7/*lista_expr*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // lista_expr ::= lista_expr macro 
            {
              Vector RESULT = null;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Vector le = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Vector m = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		
    System.out.println("[DEBUG] LISTA_EXPRESSION with a macro added found (size of LISTA:"+le.size()+")");
    le.add(m);
    RESULT=le;

              CUP$parser$result = new java_cup.runtime.Symbol(7/*lista_expr*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // lista_expr ::= lista_expr complex_expr 
            {
              Vector RESULT = null;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Vector le = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int celeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int ceright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Vector ce = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		
    System.out.println("[DEBUG] LISTA_EXPRESSION with a complex_expr added found (size of LISTA:"+le.size()+")");
    le.add(ce);
    RESULT=le;

              CUP$parser$result = new java_cup.runtime.Symbol(7/*lista_expr*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // lista_expr ::= lista_expr composed_expr 
            {
              Vector RESULT = null;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Vector le = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int coeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int coeright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Vector coe = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		
    System.out.println("[DEBUG] LISTA_EXPRESSION with a composed_expr added found (size of LISTA:"+le.size()+")");
    le.add(coe);
    RESULT=le;

              CUP$parser$result = new java_cup.runtime.Symbol(7/*lista_expr*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // lista_expr ::= lista_expr simple_expr 
            {
              Vector RESULT = null;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Vector le = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int seleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int seright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Vector se = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		
    System.out.println("[DEBUG] LISTA_EXPRESSION with a simple_expr added found (size of LISTA:"+le.size()+")");
    le.add(se);
    RESULT=le;

              CUP$parser$result = new java_cup.runtime.Symbol(7/*lista_expr*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // composed_expr ::= ATTRIBUZIONE KEYWORD TYPE ATOMO PTVIR 
            {
              Vector RESULT = null;
		int kwleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int kwright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String kw = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String t = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
    System.out.println("[DEBUG] COMPOSED_EXPR found, from keyword="+kw+" and type="+t);
    RESULT = new Vector(2);
    RESULT.add(kw);
    RESULT.add(t);
    RESULT.add(n); 

              CUP$parser$result = new java_cup.runtime.Symbol(4/*composed_expr*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // composed_expr ::= ATTRIBUZIONE KEYWORD MY_TYPE ATOMO PTVIR 
            {
              Vector RESULT = null;
		int kwleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int kwright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String kw = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int mtleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int mtright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String mt = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
    System.out.println("[DEBUG] COMPOSED_EXPR found, from keyword="+kw+" and my_type="+mt);
    RESULT = new Vector(2);
    RESULT.add(kw);
    RESULT.add(mt);
    RESULT.add(n);

              CUP$parser$result = new java_cup.runtime.Symbol(4/*composed_expr*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // simple_expr ::= expr PTVIR 
            {
              Vector RESULT = null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Vector a = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
    System.out.println("[DEBUG] SIMPLE_EXPR found, from expr="+a+" and PTVIR then...");
        RESULT=a;

              CUP$parser$result = new java_cup.runtime.Symbol(3/*simple_expr*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // macro ::= ATTRIBUZIONE KEYWORD GRAFFAPERTA PLAIN_TEXT GRAFFACHIUSA 
            {
              Vector RESULT = null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String b = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		

    RESULT = new Vector();
    System.out.println("[DEBUG] MACRO found with keyword "+a+" and PLAIN_TEXT="+b);
    if(a.equals("Documentation")){
        System.out.println("[DEBUG] Espressione di tipo Documentazione: " + b);
        RESULT.add(a);
        RESULT.add(b);}
    else if(a.equals("Code")){
        System.out.println("[DEBUG] Espressione di tipo Codice: " + b);
        RESULT.add(a);
        RESULT.add(b);}
    else 
        parser.bz.addErrorLog(BackBone.SEMANTIC, "Macro sconosciuta. Le macro possono essere solo di tipo Documentation o Code. ");

              CUP$parser$result = new java_cup.runtime.Symbol(9/*macro*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // expr ::= ATTRIBUZIONE KEYWORD error 
            {
              Vector RESULT = null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
    parser.report_error(" syntax error in expression\n",null);  
    RESULT = new Vector(1);
    RESULT.add(a);         	

              CUP$parser$result = new java_cup.runtime.Symbol(2/*expr*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // expr ::= ATTRIBUZIONE error ATOMO 
            {
              Vector RESULT = null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		
    parser.report_error(" syntax error in expression\n",null);  
    RESULT = new Vector(1);
    RESULT.add(a);    	

              CUP$parser$result = new java_cup.runtime.Symbol(2/*expr*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // expr ::= ATTRIBUZIONE KEYWORD ATOMO 
            {
              Vector RESULT = null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		String b = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		
    System.out.println("[DEBUG] EXPR found: "+a+" with atom "+b);
    RESULT = new Vector(2);
    RESULT.add(a);
    RESULT.add(b);

              CUP$parser$result = new java_cup.runtime.Symbol(2/*expr*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // blocco ::= error GRAFFAPERTA lista_expr GRAFFACHIUSA 
            {
              Vector RESULT = null;
		
    parser.report_error(" syntax error in expression\n",null);
    parser.bz.addErrorLog(BackBone.SYNTAX, "'Expression expected' per il blocco. Definizione di espressione scorretta!");

              CUP$parser$result = new java_cup.runtime.Symbol(1/*blocco*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // blocco ::= error GRAFFAPERTA lista_expr lista_blocco GRAFFACHIUSA 
            {
              Vector RESULT = null;
		
    parser.report_error(" syntax error in expression\n",null);
    parser.bz.addErrorLog(BackBone.SYNTAX, "'Expression expected' per il blocco. Definizione di espressione scorretta!");

              CUP$parser$result = new java_cup.runtime.Symbol(1/*blocco*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // blocco ::= expr GRAFFAPERTA lista_expr GRAFFACHIUSA 
            {
              Vector RESULT = null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Vector a = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Vector le = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
    if(((String)a.get(0)).equals("Agent")){
        Class agent = new Class((String)a.get(1));
        agent.setType(Class.AGENT);
        agent.setExtends("Agent", "jade.core.Agent");
        agent.addImport("jade.core.AID");
        Method m = new Method("setup");
        m.setVisibility(Method.PROTECTED);
        agent.addMethod(m);
        for(int i=0;i<le.size(); i++){
            Vector temp = (Vector) le.get(i);
            String typeExpr =(String) temp.get(0);
            if(typeExpr.equals("attrib")){
                agent.addAttribute(new Attribute((String) temp.get(1), (String) temp.get(2)));
            }
            if(typeExpr.equals("Documentation")){
                agent.addDocumentation((String) temp.get(1));
            }
        }

        RESULT = new Vector();		
        RESULT.add(agent);
    }
    else if(((String)a.get(0)).equals("Communication")){
		String stringProtocol="", stringOntology="", stringReceiver="", stringContent="", stringId="";
    	for (int i = 0; i < le.size();i++){
			Vector v = ((Vector)le.get(i));
			if (((String)v.get(0)).equals("id")) stringId = "\""+(String)v.get(1)+"\"";
			if (((String)v.get(0)).equals("protocol")) stringProtocol = (String)v.get(1);
			if (((String)v.get(0)).equals("ontology")) stringOntology = (String)v.get(1);
			if (((String)v.get(0)).equals("receiver")) stringReceiver = (String)v.get(1);
			if (((String)v.get(0)).equals("content")) stringContent = (String)v.get(1);
			
	    }    
        Class communication = new Class((String)a.get(1));
        communication.setType(Class.COMMUNICATION);
        communication.addImport("jade.lang.acl.MessageTemplate");
        communication.addImport("jade.lang.acl.ACLMessage");
        communication.addImport("jade.content.lang.Codec");
        communication.addImport("jade.content.onto.Ontology");
        Attribute id = new Attribute("String","id");
        if (!stringId.equals("")) id.setInit(stringId);
        else {
        	parser.bz.addErrorLog(BackBone.SEMANTIC, "Impossibile definire una comunicazione senza identificatore.");
        }
        Attribute receiver = new Attribute("String","receiver");
        receiver.setInit("\"\"");
        Attribute protocol = new Attribute("int","protocol");
        protocol.setInit("0");
        Attribute ontology = new Attribute("String","ontology");
        ontology.setInit("\"\"");
        Attribute content = new Attribute("String","content");
        content.setInit("\"\"");
        communication.addAttribute(id);
        communication.addAttribute(receiver);
        communication.addAttribute(protocol);
        communication.addAttribute(ontology);
        communication.addAttribute(content);
        Method m1 = new Method((String)a.get(1));
        m1.setReturnType("");
        communication.addMethod(m1);
        Method m2 = new Method((String)a.get(1));
        m2.setReturnType("");
        String[] types = new String[]{"int","String","int","String","String"};
        String[] arguments = new String[]{"id","receiver","protocol","ontology","content"};
        m2.addArgument(types,arguments);
        m2.setBody("setId(id);\nsetReceiver(receiver);\nsetProtocol(protocol);\nsetOntology(ontology);\nsetContent(content);");
        communication.addMethod(m2);
        Method setId = new Method("setId");
        setId.addArgument("int","id");
        setId.setBody("this.id=id;");
        communication.addMethod(setId);
        Method setReceiver = new Method("setReceiver");
        setReceiver.addArgument("String","receiver");
        setReceiver.setBody("this.receiver=receiver;");
        communication.addMethod(setReceiver);
        Method setProtocol = new Method("setProtocol");
        setProtocol.addArgument("int","protocol");
        setProtocol.setBody("this.protocol=protocol;");
        communication.addMethod(setProtocol);
        Method setOntology = new Method("setOntology");
        setOntology.addArgument("String","ontology");
        setOntology.setBody("this.ontology=ontology;");
        communication.addMethod(setOntology);
        Method setContent = new Method("setContent");
        setContent.addArgument("String","content");
        setContent.setBody("this.content=content;");
        communication.addMethod(setContent);
        Method getId = new Method("getId");
        getId.setReturnType("int");
        getId.setBody("return id;");
        communication.addMethod(getId);
        Method getReceiver = new Method("getReceiver");
        getReceiver.setReturnType("String");
        getReceiver.setBody("return receiver;");
        communication.addMethod(getReceiver);
        Method getProtocol = new Method("getProtocol");
        getProtocol.setReturnType("int");
        getProtocol.setBody("return protocol;");
        communication.addMethod(getProtocol);
        Method getOntology = new Method("getOntology");
        getOntology.setReturnType("String");
        getOntology.setBody("return ontology;");
        communication.addMethod(getOntology);
        Method getContent = new Method("getContent");
        getContent.setReturnType("String");
        getContent.setBody("return content;");
        communication.addMethod(getContent);
        RESULT = new Vector();
        RESULT.add(communication);
    }

    else if(((String)a.get(0)).equals("Role")){
        Class c = new Class((String)a.get(1));
        Vector pippo = new Vector();
        c.addImport("jade.core.*");
        c.setType(Class.ROLE);
        c.setExtends("OneShotBehaviour", "jade.core.behaviours.*");
        Method m = new Method("action");
        String bodyM="";
        Method costruttore = new Method((String)a.get(1));
        costruttore.setReturnType("");
        costruttore.setVisibility(Method.PUBLIC);
		costruttore.setBody("super(aref);\n");
		costruttore.addArgument("Agent", "aref");
        m.setVisibility(Method.PROTECTED);
        String bodyString = "";        
        
        for(int i=0;i<le.size(); i++){
            Vector temp = (Vector) le.get(i);
            String typeExpr =(String) temp.get(0);
            if(typeExpr.equals("attrib")){
                    c.addAttribute(new Attribute((String) temp.get(1), (String) temp.get(2)));
                    
            }
            System.out.println(temp.size());
            if(typeExpr.equals("task")){
                if(temp.size()==4){
                    String t1;
                    t1=(String)temp.get(3);
                    bodyM+="myAgent.addBehaviour(new "+((String)temp.get(2))+"(myAgent, "+t1+"));\n";
                    bodyString=bodyString+"class "+((String)temp.get(2))+" extends CyclicBehaviour {\n";
                    bodyString=bodyString+"public "+((String)temp.get(2))+"(Agent myAgent, Object "+t1+"){\n";
                    bodyString=bodyString+"super(aref);\n";
                    bodyString=bodyString+"}";
                    bodyString=bodyString+"public void action(){\n";
                    bodyString=bodyString+"//Add code here....\n";
                    bodyString=bodyString+"}\n}\n\n";
                    pippo.add(bodyString);
                }
                else if(temp.size()==5){
                    String t1;
                    String t2;
                    t1=(String)temp.get(3);
                    t2=(String)temp.get(4);
                    bodyM+="myAgent.addBehaviour(new "+((String)temp.get(2))+"(myAgent, "+t1+", "+t2+"));\n";
                    bodyString=bodyString+"class "+((String)temp.get(2))+" extends CyclicBehaviour {\n";
                    bodyString=bodyString+"public "+((String)temp.get(2))+"(Agent myAgent, Object "+t1+", Object "+t2+"){\n";
                    bodyString=bodyString+"super(aref);\n";
                    bodyString=bodyString+"}";
                    bodyString=bodyString+"public void action(){\n";
                    bodyString=bodyString+"//Add code here....\n";
                    bodyString=bodyString+"}\n}\n\n";
                    pippo.add(bodyString);
                }
            }
        }
        m.setBody(bodyM);
        c.addMethod(costruttore);
        c.addMethod(m);
        c.addNestedClass(bodyString);
        RESULT = new Vector();
        RESULT.add(c);
    }
    else if(((String)a.get(0)).equals("Society")){
        //NON DOVREBBE MAI FINIRE QUI. NON E' STATO ANCORA PREVISTA L'ESISTENZA DI SUB-SOCIETA'  
        Class c = new Class((String)a.get(1));
        c.setType(Class.SOCIETY);
        for(int i=0;i<le.size(); i++){
            Vector temp = (Vector) le.get(i);
            String typeExpr =(String) temp.get(0);
            if(typeExpr.equals("Documentation")){
	                parser.socDoc="\n Documentazione relativa alla societa' e non al singolo agente: "+((String) temp.get(1)).substring(1)+"\n";
            }
        }
        RESULT = new Vector();
        RESULT.add(c);
    }

              CUP$parser$result = new java_cup.runtime.Symbol(1/*blocco*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // blocco ::= expr GRAFFAPERTA lista_expr lista_blocco GRAFFACHIUSA 
            {
              Vector RESULT = null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Vector a = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int leleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Vector le = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int lbleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lbright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Vector lb = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
    if(((String)a.get(0)).equals("Agent")){
        Class agent = new Class((String)a.get(1));
        agent.setType(Class.AGENT);
        agent.setExtends("Agent", "jade.core.Agent");
        agent.addImport("jade.core.AID");
        Method m = new Method("setup");
        m.setVisibility(Method.PROTECTED);
        agent.addMethod(m);
        for(int i=0;i<le.size(); i++){
                Vector temp = (Vector) le.get(i);
                String typeExpr =(String) temp.get(0);
                if(typeExpr.equals("attrib")){
                        agent.addAttribute(new Attribute((String) temp.get(1), (String) temp.get(2)));
                }
                if(typeExpr.equals("Documentation")){
	                agent.addDocumentation(((String) temp.get(1)).substring(1));
	            }
        }
        for(int j=0; j<lb.size(); j++){
        Vector temp = new Vector();
        temp=(Vector)lb.get(j);
                if(((Class)temp.get(0)).getType()==Class.ROLE){
                        m.addBody("addBehaviour(new "+((Class)temp.get(0)).getName()+"(this));");
                }
        }
        RESULT = new Vector();		
        RESULT.add(agent);
        RESULT.addAll(lb);
    }
    else if(((String)a.get(0)).equals("Communication")){
    	String stringProtocol="", stringOntology="", stringReceiver="", stringContent="", stringId="";
    	for (int i = 0; i < le.size();i++){
			Vector v = ((Vector)le.get(i));
			if (((String)v.get(0)).equals("id")) stringId = "\""+(String)v.get(1)+"\"";
			if (((String)v.get(0)).equals("protocol")) stringProtocol = (String)v.get(1);
			if (((String)v.get(0)).equals("ontology")) stringOntology = (String)v.get(1);
			if (((String)v.get(0)).equals("receiver")) stringReceiver = (String)v.get(1);
			if (((String)v.get(0)).equals("content")) stringContent = (String)v.get(1);

	    }    
        Class communication = new Class((String)a.get(1));
        communication.setType(Class.COMMUNICATION);
        communication.addImport("jade.lang.acl.MessageTemplate");
        communication.addImport("jade.lang.acl.ACLMessage");
        communication.addImport("jade.content.lang.Codec");
        communication.addImport("jade.content.onto.Ontology");
        Attribute id = new Attribute("String","id");
        if (!stringId.equals("")) id.setInit(stringId);
        else {
        	parser.bz.addErrorLog(BackBone.SEMANTIC, "Impossibile definire una comunicazione senza identificatore.");
        }
        Attribute receiver = new Attribute("String","receiver");
        receiver.setInit("\"\"");
        Attribute protocol = new Attribute("int","protocol");
        protocol.setInit("0");
        Attribute ontology = new Attribute("String","ontology");
        ontology.setInit("\"\"");
        Attribute content = new Attribute("String","content");
        content.setInit("\"\"");
        communication.addAttribute(id);
        communication.addAttribute(receiver);
        communication.addAttribute(protocol);
        communication.addAttribute(ontology);
        communication.addAttribute(content);
        Method m1 = new Method((String)a.get(1));
        m1.setReturnType("");
        communication.addMethod(m1);
        Method m2 = new Method((String)a.get(1));
        m2.setReturnType("");
        String[] types = new String[]{"int","String","int","String","String"};
        String[] arguments = new String[]{"id","receiver","protocol","ontology","content"};
        m2.addArgument(types,arguments);
        m2.setBody("setId(id);\nsetReceiver(receiver);\nsetProtocol(protocol);\nsetOntology(ontology);\nsetContent(content);");
        communication.addMethod(m2);
        Method setId = new Method("setId");
        setId.addArgument("int","id");
        setId.setBody("this.id=id;");
        communication.addMethod(setId);
        Method setReceiver = new Method("setReceiver");
        setReceiver.addArgument("String","receiver");
        setReceiver.setBody("this.receiver=receiver;");
        communication.addMethod(setReceiver);
        Method setProtocol = new Method("setProtocol");
        setProtocol.addArgument("int","protocol");
        setProtocol.setBody("this.protocol=protocol;");
        communication.addMethod(setProtocol);
        Method setOntology = new Method("setOntology");
        setOntology.addArgument("String","ontology");
        setOntology.setBody("this.ontology=ontology;");
        communication.addMethod(setOntology);
        Method setContent = new Method("setContent");
        setContent.addArgument("String","content");
        setContent.setBody("this.content=content;");
        communication.addMethod(setContent);
        Method getId = new Method("getId");
        getId.setReturnType("int");
        getId.setBody("return id;");
        communication.addMethod(getId);
        Method getReceiver = new Method("getReceiver");
        getReceiver.setReturnType("String");
        getReceiver.setBody("return receiver;");
        communication.addMethod(getReceiver);
        Method getProtocol = new Method("getProtocol");
        getProtocol.setReturnType("int");
        getProtocol.setBody("return protocol;");
        communication.addMethod(getProtocol);
        Method getOntology = new Method("getOntology");
        getOntology.setReturnType("String");
        getOntology.setBody("return ontology;");
        communication.addMethod(getOntology);
        Method getContent = new Method("getContent");
        getContent.setReturnType("String");
        getContent.setBody("return content;");
        communication.addMethod(getContent);
        RESULT = new Vector();
        RESULT.add(communication);
    }
  else if(((String)a.get(0)).equals("Role")){
        Class c = new Class((String)a.get(1));
        Vector pippo = new Vector();
        c.addImport("jade.core.*");
        c.setType(Class.ROLE);
        c.setExtends("OneShotBehaviour", "jade.core.behaviours.*");
        Method m = new Method("action");
        String bodyM="";
        Method costruttore = new Method((String)a.get(1));
        costruttore.setReturnType("");
        costruttore.setVisibility(Method.PUBLIC);
		costruttore.setBody("super(aref);\n");
		costruttore.addArgument("Agent", "aref");
        m.setVisibility(Method.PROTECTED);
        String bodyString = "";        
        
        for(int i=0;i<le.size(); i++){
            Vector temp = (Vector) le.get(i);
            String typeExpr =(String) temp.get(0);
            if(typeExpr.equals("attrib")){
                    c.addAttribute(new Attribute((String) temp.get(1), (String) temp.get(2)));
                    
            }
            System.out.println(temp.size());
            if(typeExpr.equals("task")){
                if(temp.size()==4){
                    String t1;
                    t1=(String)temp.get(3);
                    bodyM+="myAgent.addBehaviour(new "+((String)temp.get(2))+"(myAgent, "+t1+"));\n";
                    bodyString=bodyString+"class "+((String)temp.get(2))+" extends CyclicBehaviour {\n";
                    bodyString=bodyString+"public "+((String)temp.get(2))+"(Agent myAgent, Object "+t1+"){\n";
                    bodyString=bodyString+"super(aref);\n";
                    bodyString=bodyString+"}";
                    bodyString=bodyString+"public void action(){\n";
                    bodyString=bodyString+"//Add code here....\n";
                    bodyString=bodyString+"}\n}";
                    pippo.add(bodyString);
                }
                else if(temp.size()==5){
                    String t1;
                    String t2;
                    t1=(String)temp.get(3);
                    t2=(String)temp.get(4);
                    bodyM+="myAgent.addBehaviour(new "+((String)temp.get(2))+"(myAgent, "+t1+", "+t2+"));\n";
                    bodyString=bodyString+"class "+((String)temp.get(2))+" extends CyclicBehaviour {\n";
                    bodyString=bodyString+"public "+((String)temp.get(2))+"(Agent myAgent, Object "+t1+", Object "+t2+"){\n";
                    bodyString=bodyString+"super(aref);\n";
                    bodyString=bodyString+"}";
                    bodyString=bodyString+"public void action(){\n";
                    bodyString=bodyString+"//Add code here....\n";
                    bodyString=bodyString+"}\n}";
                    pippo.add(bodyString);
                }
            }
        }
        m.setBody(bodyM);
        c.addMethod(costruttore);
        c.addMethod(m);
        c.addNestedClass(bodyString);
        RESULT = new Vector();
        RESULT.add(c);
    }
    else if(((String)a.get(0)).equals("Society")){
        //NON DOVREBBE MAI FINIRE QUI. NON E' STATO ANCORA PREVISTA L'ESISTENZA DI SUB-SOCIETA'  
        Class c = new Class((String)a.get(1));
        c.setType(Class.SOCIETY);
        for(int i=0;i<le.size(); i++){
            Vector temp = (Vector) le.get(i);
            String typeExpr =(String) temp.get(0);
            if(typeExpr.equals("Documentation")){
	                parser.socDoc="\n Documentazione relativa alla societa' e non al singolo agente: "+((String) temp.get(1)).substring(1)+"\n";
            }
        }
        RESULT = new Vector();
        RESULT.add(c);
        RESULT.addAll(lb);
    }

              CUP$parser$result = new java_cup.runtime.Symbol(1/*blocco*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // lista_blocco ::= blocco 
            {
              Vector RESULT = null;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Vector b = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		
    RESULT = new Vector();
    RESULT.add(b);

              CUP$parser$result = new java_cup.runtime.Symbol(8/*lista_blocco*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // lista_blocco ::= lista_blocco blocco 
            {
              Vector RESULT = null;
		int lbleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lbright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Vector lb = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Vector b = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		
    System.out.println("[DEBUG] Ho trovato una LISTA_BLOCCO found, con la dimensione: "+lb.size());
    lb.add(b);
    RESULT=lb;

              CUP$parser$result = new java_cup.runtime.Symbol(8/*lista_blocco*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // root ::= blocco 
            {
              String RESULT = null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right;
		Vector a = (Vector)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-0)).value;
		
    System.out.println("[DEBUG] Trovato un root!");

    if(((Class)a.get(0)).getType()==Class.SOCIETY){
        if(a.size()<2){
                parser.bz.addErrorLog(BackBone.SEMANTIC, "Non  possibile avere una societ deserta.");
        }else{
                Vector errorLog = parser.bz.getErrorLog(); //Preserva il log di errore
                parser.bz=new BackBone(((Class)a.get(0)).getName());
                parser.bz.setErrorLog(errorLog); //Ripristina il log di errore
                
        }
		        
    }
    else{
        parser.bz.addErrorLog(BackBone.SEMANTIC, "Il ROOT pu essere composto soltanto da una societ.");
    }

    for (int i = 1; i < a.size(); i++){ //Per ogni blocco[] escluso il primo (header)
        Vector temp2 = (Vector) a.get(i);
        Class header2 = ((Class)temp2.get(0)); 
        if(header2.getType()==Class.AGENT){
	        System.out.println("[DEBUG] Generazione di un file di tipo Agent.java");
	        header2.addDocumentation(parser.socDoc);
	        parser.bz.addClass(header2);
	
	        for (int insideAgent=1; insideAgent < temp2.size();insideAgent++){
	            Vector temp3 = (Vector) temp2.get(insideAgent);
	            Class header3 = ((Class)temp3.get(0));  
	
	            if (header3.getType()==Class.ROLE){
	              		System.out.println("[DEBUG] Aggiunto un ruolo.java!!!");
	                  	parser.bz.addClass(header3);
	            }
	        }
	        
    	}
	    else if(header2.getType()==Class.COMMUNICATION){
	                  System.out.println("[DEBUG] Generazione di un file di tipo Communication.java!!!");
	                  parser.bz.addClass(header2);
	    }	 
	    else if(header2.getType()==Class.SOCIETY){
	        parser.bz.addErrorLog(BackBone.SEMANTIC, "L'esistenza di sub-societ annidate non  permessa (ancora).");
	    }
	    else {
          	parser.bz.addErrorLog(BackBone.SEMANTIC, "????Nessun agente per la societ descritta????"+((Class)temp2.get(0)).getType());
    	}
	}

              CUP$parser$result = new java_cup.runtime.Symbol(11/*root*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // agent_lang ::= root 
            {
              String RESULT = null;
		
    System.out.println("[DEBUG] Creazione del codice della societ di agenti...");
    parser.bz.toFile();	

              CUP$parser$result = new java_cup.runtime.Symbol(10/*agent_lang*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= agent_lang EOF 
            {
              Object RESULT = null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String start_val = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = new java_cup.runtime.Symbol(0/*$START*/, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-0)).right, RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

